const { expect } = require("chai");
const { waffle, network } = require("hardhat");
const { loadFixture } = waffle;

const { expectRevert, expectEvent, BN } = require("@openzeppelin/test-helpers");

const { address, mineBlock, blockNumber } = require("../Utils/Ethereum");

const EIP712 = require("../Utils/EIP712");
// const EIP712Ethers = require("../Utils/EIP712Ethers");
const { getAccountsPrivateKeysBuffer } = require("../Utils/hardhat_utils");

const StakingLogic = artifacts.require("StakingMockup");
const StakingProxy = artifacts.require("StakingProxy");
const TestToken = artifacts.require("TestToken");
const VestingLogic = artifacts.require("VestingLogic");
//Upgradable Vesting Registry
const VestingRegistryLogic = artifacts.require("VestingRegistryLogic");
const VestingRegistryProxy = artifacts.require("VestingRegistryProxy");

const TOTAL_SUPPLY = "10000000000000000000000000";
const DELAY = 86400 * 14;
const TWO_WEEKS = 86400 * 14;

contract("Staking", (accounts) => {
    const name = "Test token";
    const symbol = "TST";

    const addr_zero = address(0);

    let root, a1, a2, a3, chainId;
    let rootSigner,  a1Signer;

    let token, staking;
    let MAX_VOTING_WEIGHT;

    let kickoffTS, inThreeYears;

    let vestingLogic1, vestingLogic2;

    let timestamp0, timestamp1, timestamp2;
    let stakeA, stakeB, totalStake; 

    async function deploymentAndInitFixture(_wallets, _provider) {
        chainId = 1; // await web3.eth.net.getId(); See: https://github.com/trufflesuite/ganache-core/issues/515
        await web3.eth.net.getId();
        token = await TestToken.new(name, symbol, 18, TOTAL_SUPPLY);

        let stakingLogic = await StakingLogic.new(token.address);
        staking = await StakingProxy.new(token.address);
        await staking.setImplementation(stakingLogic.address);
        staking = await StakingLogic.at(staking.address);
        //Upgradable Vesting Registry
        vestingRegistryLogic = await VestingRegistryLogic.new();
        vesting = await VestingRegistryProxy.new();
        await vesting.setImplementation(vestingRegistryLogic.address);
        vesting = await VestingRegistryLogic.at(vesting.address);

        await staking.setVestingRegistry(vesting.address);

        MAX_VOTING_WEIGHT = await staking.MAX_VOTING_WEIGHT.call();

        kickoffTS = await staking.kickoffTS.call();
        inThreeYears = kickoffTS.add(new BN(DELAY * 26 * 3));
    }

    before(async () => {
        [root, a1, a2, a3, ...accounts] = accounts;
        [rootSigner,  a1Signer] = await ethers.getSigners();
        
        vestingLogic1 = await VestingLogic.new();
        vestingLogic2 = await VestingLogic.new();        
    });

    beforeEach(async () => {
        await loadFixture(deploymentAndInitFixture);
        
        // last 3 timestamps must be a groupshot or exploit risks negative yield
        timestamp0 = kickoffTS.add(new BN(TWO_WEEKS * 42));
        timestamp1 = kickoffTS.add(new BN(TWO_WEEKS * 54));
        timestamp2 = kickoffTS.add(new BN(TWO_WEEKS * 56));
        //timestamp3 = kickoffTS.add(new BN(TWO_WEEKS * 56));

        stakeA = 1;
        stakeB = 9999;
        totalStake = stakeA + stakeB; // if != 10k adjust hardcoded weightedPower function
        
        await token.transfer(a1, totalStake+1);
        await token.approve(staking.address, totalStake, { from: a1 });
        await mineBlock();
    });


    describe("Voting Power shaking exploit", () => {

        it("stakers get voting power proportional to tokens staked and stake duration", async () => {
            await staking.stake(totalStake, timestamp2, addr_zero, addr_zero, { from: a1 });
            
            await mineBlock();
            await mineBlock();

            expect((await staking.getPriorVotes.call(
                                                a1,
                                                new BN(await blockNumber()-1),
                                                timestamp0
                                                )).toString()).to.equal(weightedPower(totalStake).toString());
            expect((await staking.getPriorTotalVotingPower.call(
                                                new BN(await blockNumber()-1),
                                                timestamp0, { from : a1 }
                                                )).toString()).to.equal(weightedPower(totalStake).toString());
            expect((await staking.getPriorWeightedStake.call(
                                                a1,
                                                new BN(await blockNumber()-1),
                                                timestamp0
                                                )).toString()).to.equal(weightedPower(totalStake).toString());
        });

        it("sustains shaking in a single block", async () => {
            // exploit setup
            await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });

            let initBlock = await blockNumber();
            console.log('initBlock', initBlock.toString())
            //console.log("first stake block# :", initBlock );

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);
            await network.provider.send("evm_setIntervalMining", [0]);

            // beware, test won't fail nor warn if one or more of these unawaited txs runs out of gas!

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            console.log('before queuing shaking promises')
            const promises = [

                staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000 }).then((r) => (console.log('1st mined in', r.receipt.blockNumber), r)).catch((e) => console.log('1st fail', e)), //160k

                staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000 }).then((r) => (console.log('2nd mined in', r.receipt.blockNumber), r)).catch((e) => console.log('2nd fail', e)), //285k

                // continue shaking
                staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000 }).then((r) => (console.log('4th mined in', r.receipt.blockNumber), r)).catch((e) => console.log('4th fail', e)), //61k --- this line boosts the VP a lot
            ];
            console.log('after queuing shaking promises');

            // reactivate mining
            console.log('before evm_setIntervalMining');
            await network.provider.send("evm_setIntervalMining", [1000]);
            console.log('after evm_setIntervalMining');

            // mine all pending txs above (which are waiting in the mempool)
            await mineBlock();
            let exploitBlock = await blockNumber();
            console.log('exploitBlock', exploitBlock.toString())
            //console.log("exploit block# :", exploitBlock );
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock+1);

            //await Promise.all(promises)

            // extend leftover stake (A) from t1 to t3
            // canary tx, if it is mined, exploit is mined (in previous block)
            console.log('before canary tx');
            let tx = await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
            console.log(`after canary tx (mined in block ${tx.receipt.blockNumber})`);
            //console.log("canary tx mined at block#", tx.receipt.blockNumber );

            // last strong shake
            // another unexplained booster
            console.log('before last strong shake');
            tx = await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
            console.log(`after last strong shake (mined in block ${tx.receipt.blockNumber})`);

            await mineBlock();
            await mineBlock();

            //console.log("measure for t1 at block# :", await blockNumber() );
            expect((await staking.getPriorVotes.call(
                a1,
                new BN(await blockNumber()-1),
                timestamp0
            )).toString()).to.equal(weightedPower(totalStake).toString());

            expect((await staking.getPriorTotalVotingPower.call(
                new BN(await blockNumber()-1),
                timestamp0, { from : a1 }
            )).toString()).to.equal(weightedPower(totalStake).toString());

            expect((await staking.getPriorWeightedStake.call(
                a1,
                new BN(await blockNumber()-1),
                timestamp0
            )).toString()).to.equal(weightedPower(totalStake).toString());

        });

        it("sustains delegationless shaking in a single block", async () => {
            // exploit setup
            await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });
            await mineBlock();
            console.log("VP after stakeA",
                staking.getPriorTotalVotingPower.call(
                new BN(await blockNumber()-1),
                timestamp0, { from : a1 }
            ));
            let initBlock = await blockNumber();
            console.log('initBlock', initBlock.toString())
            //console.log("first stake block# :", initBlock );

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);
            await network.provider.send("evm_setIntervalMining", [0]);

            // beware, test won't fail nor warn if one or more of these unawaited txs runs out of gas!

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            console.log('before queuing shaking promises')
            const promises = [
                staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000 }).then((r) => (console.log('1st mined in', r.receipt.blockNumber), r)).catch((e) => console.log('1st fail', e)), //160k
                staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000 }).then((r) => (console.log('2nd mined in', r.receipt.blockNumber), r)).catch((e) => console.log('2nd fail', e)), //285k
            ];

            // reactivate mining
            await network.provider.send("evm_setIntervalMining", [1000]);
            console.log('after evm_setIntervalMining');

            // mine all pending txs above (which are waiting in the mempool)
            await mineBlock();
            
            let exploitBlock = await blockNumber();
            console.log('exploitBlock', exploitBlock.toString())
            //console.log("exploit block# :", exploitBlock );
            // fails test if exploit does not fit in single block
            expect(exploitBlock).to.equal(initBlock+1);

            // extend leftover stake (A) from t1 to t2
            // canary tx, if it is mined, exploit is mined (in previous block)
            //console.log('before canary tx');
            let tx = await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
            //console.log(`after canary tx (mined in block ${tx.receipt.blockNumber})`);
            //console.log("canary tx mined at block#", tx.receipt.blockNumber );

            mineBlock();
            console.log("VP after exploit block",
                staking.getPriorTotalVotingPower.call(
                new BN(await blockNumber()-1),
                timestamp0, { from : a1 }
            ));

            // last strong shake
            // another unexplained booster
            //console.log('before last strong shake');
            await staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 500_000 });
            //console.log(`after last strong shake (mined in block ${tx.receipt.blockNumber})`);

            await mineBlock();

            //console.log("measure for t1 at block# :", await blockNumber() );
            expect((await staking.getPriorVotes.call(
                a1,
                new BN(await blockNumber()-1),
                timestamp0
            )).toString()).to.equal(weightedPower(totalStake).toString());

            expect((await staking.getPriorTotalVotingPower.call(
                new BN(await blockNumber()-1),
                timestamp0, { from : a1 }
            )).toString()).to.equal(weightedPower(totalStake).toString());

            expect((await staking.getPriorWeightedStake.call(
                a1,
                new BN(await blockNumber()-1),
                timestamp0
            )).toString()).to.equal(weightedPower(totalStake).toString());

        });

        it("sustains shaking in a single block (and loop): will fail", async () => {
            // exploit setup
            await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });

            let initBlock = await blockNumber();

            // stop mining
            await network.provider.send("evm_setAutomine", [false]);
            await network.provider.send("evm_setIntervalMining", [0]);

            // tool for debugging promises
            let debugPromise = (name, p) => (
                p.then((r) => {
                    console.log(`${name} mined in ${r.receipt.blockNumber}`);
                    return r;
                }).catch((e) => {
                    console.log(name, 'failed\n', e);
                    throw e;
                })
            )
            // uncomment this if you don't want to debug
            //debugPromise = (name, p) => p; // if you don't want debugging

            let nonce = await web3.eth.getTransactionCount(a1);

            // all of the following calls will be mined together,
            // with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
            const promises = [
                debugPromise('stake', staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000, nonce: nonce++ })),
                debugPromise('first extend', staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000, nonce: nonce++ })),
                //debugPromise('first delegate', staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000, nonce: nonce++ })),
                //debugPromise('canary extend', staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000, nonce: nonce++ })),
            ];

            // Mine above transactions
            await network.provider.send("evm_setIntervalMining", [1000]);
            await Promise.all(promises);

            // Reactivate automining
            await network.provider.send("evm_setIntervalMining", [0]);
            // loop to skyrocket VP
            for (let i = 0; i < 8; i++) {
                
                promises.push(
                    debugPromise(`delegate${i}`,
                        staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000, nonce: nonce++ })),
                    
                );
                promises.push(
                    debugPromise(`extend${i}`,
                       staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 350_000, nonce: nonce++ })),
                );
            }
            

            await network.provider.send("evm_setIntervalMining", [1000]);
            await Promise.all(promises);

            await network.provider.send("evm_setAutomine", [true]);

            // mine all pending txs above (which are waiting in the mempool)
            let exploitBlock = await blockNumber();
            console.log('exploitBlock', exploitBlock.toString())
            expect(exploitBlock).to.equal(initBlock + 1);

            // killing blow : delegate 
            await staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000 });
            await staking.delegate(a1, timestamp2, { from: a1, gasLimit: 200_000 });

            // Mine a single block, this seems to be needed
            await mineBlock();

            const checkedBlockNumber = exploitBlock;

            expect((await staking.getPriorVotes.call(
                a1,
                checkedBlockNumber,
                timestamp0
            )).toString()).to.equal(weightedPower(totalStake).toString());

            expect((await staking.getPriorTotalVotingPower.call(
                checkedBlockNumber,
                timestamp0, { from : a1 }
            )).toString()).to.equal(weightedPower(totalStake).toString());

            expect((await staking.getPriorWeightedStake.call(
                a1,
                checkedBlockNumber,
                timestamp0
            )).toString()).to.equal(weightedPower(totalStake).toString());

        });
    });

    function weightedPower(stake) {
        //return weightingFunction(stake, now, maxDuration, MAX_VOTING_WEIGHT, weightFactor)
        return 39000; // temp value for this specific scenario when measured for t0 (totalStake=10k until t3)
    }

    function weightingFunction(stake, time, maxDuration, maxVotingWeight, weightFactor) {
        let x = maxDuration - time;
        let mD2 = maxDuration * maxDuration;
        return Math.floor((stake * (Math.floor((maxVotingWeight * weightFactor * (mD2 - x * x)) / mD2) + weightFactor)) / weightFactor);
    }
});
