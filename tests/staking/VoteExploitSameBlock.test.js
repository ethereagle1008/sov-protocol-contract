const { expect } = require("chai");
const { waffle, network } = require("hardhat");
const { loadFixture } = waffle;

const { expectRevert, expectEvent, BN } = require("@openzeppelin/test-helpers");

const { address, mineBlock, blockNumber } = require("../Utils/Ethereum");

const EIP712 = require("../Utils/EIP712");
// const EIP712Ethers = require("../Utils/EIP712Ethers");
const { getAccountsPrivateKeysBuffer } = require("../Utils/hardhat_utils");

const StakingLogic = artifacts.require("StakingMockup");
const StakingProxy = artifacts.require("StakingProxy");
const TestToken = artifacts.require("TestToken");
const VestingLogic = artifacts.require("VestingLogic");
//Upgradable Vesting Registry
const VestingRegistryLogic = artifacts.require("VestingRegistryLogic");
const VestingRegistryProxy = artifacts.require("VestingRegistryProxy");

const TOTAL_SUPPLY = "10000000000000000000000000";
const DELAY = 86400 * 14;
const TWO_WEEKS = 86400 * 14;

contract("Staking", (accounts) => {
	const name = "Test token";
	const symbol = "TST";

	const addr_zero = address(0);

	let root, a1, a2, a3, chainId;
	let rootSigner, a1Signer;

	let token, staking;
	let MAX_VOTING_WEIGHT;

	let kickoffTS, inThreeYears;

	let vestingLogic1, vestingLogic2;

	let timestamp0, timestamp1, timestamp2;
	let stakeA, stakeB, totalStake;

	// tool for debugging promises
	let debugPromise = (name, p) => p;
	// Uncomment for more debugging
	//debugPromise = (name, p) => (
	//	p
	//		.then((r) => {
	//			console.log(`${name} mined in ${r.receipt.blockNumber}`);
	//			return r;
	//		})
	//		.catch((e) => {
	//			console.log(name, "failed\n", e);
	//			throw e;
	//		})
	//);

	async function deploymentAndInitFixture(_wallets, _provider) {
		chainId = 1; // await web3.eth.net.getId(); See: https://github.com/trufflesuite/ganache-core/issues/515
		await web3.eth.net.getId();
		token = await TestToken.new(name, symbol, 18, TOTAL_SUPPLY);

		let stakingLogic = await StakingLogic.new(token.address);
		staking = await StakingProxy.new(token.address);
		await staking.setImplementation(stakingLogic.address);
		staking = await StakingLogic.at(staking.address);
		//Upgradable Vesting Registry
		vestingRegistryLogic = await VestingRegistryLogic.new();
		vesting = await VestingRegistryProxy.new();
		await vesting.setImplementation(vestingRegistryLogic.address);
		vesting = await VestingRegistryLogic.at(vesting.address);

		await staking.setVestingRegistry(vesting.address);

		MAX_VOTING_WEIGHT = await staking.MAX_VOTING_WEIGHT.call();

		kickoffTS = await staking.kickoffTS.call();
		inThreeYears = kickoffTS.add(new BN(DELAY * 26 * 3));
	}

	before(async () => {
		[root, a1, a2, a3, ...accounts] = accounts;
		[rootSigner, a1Signer] = await ethers.getSigners();

		vestingLogic1 = await VestingLogic.new();
		vestingLogic2 = await VestingLogic.new();
	});

	beforeEach(async () => {
		await loadFixture(deploymentAndInitFixture);

		// last 3 timestamps must be a groupshot or exploit risks negative yield
		timestamp0 = kickoffTS.add(new BN(TWO_WEEKS * 42));
		timestamp1 = kickoffTS.add(new BN(TWO_WEEKS * 54));
		timestamp2 = kickoffTS.add(new BN(TWO_WEEKS * 56));
		//timestamp3 = kickoffTS.add(new BN(TWO_WEEKS * 56));

		stakeA = 1;
		stakeB = 9999;
		totalStake = stakeA + stakeB; // if != 10k adjust hardcoded weightedPower function

		await token.transfer(a1, totalStake + 1);
		await token.approve(staking.address, totalStake, { from: a1 });
		await mineBlock();
	});

	afterEach(async() => {
		// Make sure we don't accidentally leave interval mining on after the tests
		await network.provider.send("evm_setAutomine", [true]);
		await network.provider.send("evm_setIntervalMining", [0]);
	});

	describe("Voting Power shaking exploit", () => {
		it("stakers get voting power proportional to tokens staked and stake duration", async () => {
			// This is the null case, no exploit here
			await staking.stake(totalStake, timestamp1, addr_zero, addr_zero, { from: a1 });

			await mineBlock();

			const checkedBlockNumber = new BN((await blockNumber()) - 1);
			const expectedVotingPower = "35000"; // pre-calculated

			expect((await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);
			expect((await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, { from: a1 })).toString()).to.equal(
				expectedVotingPower
			);
			expect((await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);
		});

		it("sustains shaking in a single block", async () => {
			// exploit setup
			await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });

			let initBlock = await blockNumber();

			// stop mining
			await network.provider.send("evm_setAutomine", [false]);
			await network.provider.send("evm_setIntervalMining", [0]);

			// all of the following calls will be mined together,
			// with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
			const promises = [
				debugPromise("1st", staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000 })),
				debugPromise("2nd", staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000 })),
				// continue shaking
				debugPromise("3rd", staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000 })),
			];

			// mine all pending txs above (which are waiting in the mempool)
			await network.provider.send("evm_setIntervalMining", [1000]);
			try {
				await Promise.all(promises);
			} catch (e) {
				// Some promise failed -- this is OK but we should check explicitly which one failed
				// TODO: check receipt of failed promise
			}

			// Re-enable mining
			await network.provider.send("evm_setAutomine", [true]);
			await network.provider.send("evm_setIntervalMining", [0]);

			let exploitBlock = await blockNumber();
			// fails test if exploit does not fit in single block
			expect(exploitBlock).to.equal(initBlock + 1);

			// mine a block, needed
			await mineBlock();

			const checkedBlockNumber = new BN((await blockNumber()) - 1);
			const expectedVotingPower = "35000"; // pre-calculated

			expect((await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);

			expect((await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, { from: a1 })).toString()).to.equal(
				expectedVotingPower
			);

			expect((await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);
		});

		it("sustains delegationless shaking in a single block", async () => {
			// exploit setup
			await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });
			await mineBlock();

			let initBlock = await blockNumber();

			// stop mining
			await network.provider.send("evm_setAutomine", [false]);
			await network.provider.send("evm_setIntervalMining", [0]);

			// all of the following calls will be mined together,
			// with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
			const promises = [
				debugPromise("1st", staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000 })),
				debugPromise("2nd", staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 400_000 })),
			];

			// reactivate mining
			await network.provider.send("evm_setIntervalMining", [1000]);

			// mine all pending txs above (which are waiting in the mempool)
			try {
				await Promise.all(promises);
			} catch (e) {
				// Some promise failed -- this is OK but we should check explicitly which one failed
				// TODO: check receipt of failed promise
			}

			// Re-enable mining
			await network.provider.send("evm_setAutomine", [true]);
			await network.provider.send("evm_setIntervalMining", [0]);

			let exploitBlock = await blockNumber();
			// fails test if exploit does not fit in single block
			expect(exploitBlock).to.equal(initBlock + 1);

			// Mine a block -- needed
			await mineBlock();

			const checkedBlockNumber = new BN((await blockNumber()) - 1);
			const expectedVotingPower = "35000"; // pre-calculated

			//console.log("measure for t1 at block# :", await blockNumber() );
			expect((await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);

			expect((await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, { from: a1 })).toString()).to.equal(
				expectedVotingPower
			);

			expect((await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);
		});

		it("sustains shaking in a single block (and loop): will fail", async () => {
			// exploit setup
			await staking.stake(stakeA, timestamp1, addr_zero, addr_zero, { from: a1 });
			await mineBlock();

			let initBlock = await blockNumber();

			// stop mining
			await network.provider.send("evm_setAutomine", [false]);
			await network.provider.send("evm_setIntervalMining", [0]);

			let nonce = await web3.eth.getTransactionCount(a1);

			// all of the following calls will be mined together,
			// with initBlock as their parent --containing a fresh stakeA and no trace of stakeB in it
			const promises = [
				debugPromise(
					"stake",
					staking.stake(stakeB, timestamp1, addr_zero, addr_zero, { from: a1, gasLimit: 250_000, nonce: nonce++ })
				),
			];
			// loop to skyrocket VP
			for (let i = 0; i < 8; i++) {
				promises.push(
					debugPromise(
						`extend${i}`,
						staking.extendStakingDuration(timestamp1, timestamp2, { from: a1, gasLimit: 350_000, nonce: nonce++ })
					)
				);
				promises.push(
					debugPromise(`delegate${i}`, staking.delegate(a1, timestamp1, { from: a1, gasLimit: 200_000, nonce: nonce++ }))
				);
			}

			// Mine the above transactions
			await network.provider.send("evm_setIntervalMining", [1000]);
			try {
				await Promise.all(promises);
			} catch (e) {
				// Some promise failed -- this is OK but we should check explicitly which one failed
				// TODO: check receipt of failed promise
			}

			// Reactivate automining
			await network.provider.send("evm_setAutomine", [true]);
			await network.provider.send("evm_setIntervalMining", [0]);

			let exploitBlock = await blockNumber();
			expect(exploitBlock).to.equal(initBlock + 1);

			// Mine a block -- needed
			await mineBlock();

			const checkedBlockNumber = new BN((await blockNumber()) - 1);
			const expectedVotingPower = "35000"; // pre-calculated

			expect((await staking.getPriorVotes.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);

			expect((await staking.getPriorTotalVotingPower.call(checkedBlockNumber, timestamp0, { from: a1 })).toString()).to.equal(
				expectedVotingPower
			);

			expect((await staking.getPriorWeightedStake.call(a1, checkedBlockNumber, timestamp0)).toString()).to.equal(expectedVotingPower);
		});
	});
});
